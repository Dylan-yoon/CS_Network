### 02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다

_프로토콜 스택과 LAN 어댑터의 탐험

- 01. 소켓을 작성한다 (그림 2-1)
    1. 프로토콜 스택의 내부 구성
        - 네트워크 애플리케이션 : 브라우저, 메일러, 웹 서버, 메일 서버등의 프로그램이 여기 층에 해당
            - Socket 라이브러리 이씅며, 그 안에는 리졸버가 내장 → DNS 서버 조회하는 동작 실행
        - OS : 프로토콜 스택
            - TCP 프로토콜, UDP 프로토콜
            - IP 프로토콜
        - LAN 드라이버 : LAN 어댑터의 하드웨어를 제어
    2. 소켓의 실체는 통신 제어용 제어 정보
        - 프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 통신 동작을 제어하기 위한 제어 정보를 기록 → 소켓의 실체 (제어 정보)
        - 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하며 움직임 (그림2-2)
        - ‘Socket’ Socket 라이브러리 / ‘socket’ Socket 라이브러리 안에 프로그램 / ‘소켓’ 양끝에 있는 출입구
    3. Socket을 호출했을 때의 동작 (그림 2-3)
        - 소켓을 만들 때 한 개의 메모리 영역을 확보하고 초기 상태라는 것을 이 영역에 기록
        - 디스크립터 : 프로토콜 스택의 내부에 있는 다수의 소켓 중 어느것을 가리키는 지 나타내는 정보
        - 디스크립터를 받은 애플리케이션은 이후 프로토콜 스택에 데이터 송/수신 동작을 의뢰할 때 디스크립터에 통지 → 통신 상대 정보를 일일이 통지 받을 필요가 없음
- 02. 서버에 접속한다.
    1. 접속의 의미
        - 버퍼 메모리 : 데이터 송수신 동작을 실행할 때는 송수신 데이터를 일시적으로 저장하는 메모리 영역
        - 접속 동작
            1. 통신 상대와의 사이에 제어 정보를 주고 받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는 것
            2. 버퍼 메모리의 확보
    2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다.
        - TCP 헤더 (표 2-1)
            1. 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보 - TCP 프로토콜의 사양
        - 헤더에 기록된 제어 정보에 의해 이루어짐
            - 데이터를 저장한 패킷
            - 제어 정보만 있는 패킷
        - 제어 정보는 소켓에 기록하여 프로코로 스택의 동작을 제어하기 위한 정보
            - 소켓에 기록한 제어 정보는 상대측에서 볼 수 없음
    3. 접속 동작의 실체
        - 접속 동작의 첫 걸음은 TCP 담당하는 부분에서 접속을 나타내는 제어 정보를 기록한 TCP 헤더를 만드는 것, TCP 헤더의 송신처와 수신처의 포트 번호로 접속하는 소켓을 지정
            
        - 프로세스
            
            1. Socket 라이브러리의 connect 호출
            2. 서버측의 IP 주소와 포트번호 → 프로토콜 스택의 TCP 담당부분으로 전달
            3. TCP 담당 부분은 IP 주소로 표시된 서버의 TCP 담당 부분과의 사이에 제어 정보를 주고 받음
                1. 송수신 동작의 개시를 나타내는 제어 정보를 기록한 헤더 생성 (송수신처, 수신처 포트번호)
                2. 송신처가 되는 클라이언트 측의 소켓과 수신처가 되는 서버측의 소켓을 지정
                3. 접속 소켓결정되어 컨트롤 비트 SYN = 1
            4. TCP 헤더 → IP 담당 부분 전달 (송신 의뢰) → IP 담당 부분 패킷 송신 동작 → 서버측 IP 담당 부분 수신
            5. 서버측 IP 담당 부분 → 서버측 TCP 담당 부분 헤더 조사 → 소켓 탐색 → 필요 정보 기록 접속동작 진행중 상태 → 서버 TCP 담당 부분 응답 돌려보냄
            6. 서버측 TCP 헤더 생성 (송신처, 수신처 포트번호 SYN) → ACK = 1 응답 생성
            7. 클라이언트 측 서버측에서 온 TCP 헤더 SYN == 1 접속 성공 → 제어 정보 기록
            8. 클라이언트 측 서버측에서 온 ACK 비트 도착한것 서버에 알리기위해 ACK = 1 TCP 헤더 반송
            9. TCP 헤더 서버측 수신 시 `접속 동작` 종료
            
            → 소켓 데이터 송수신 가능 상태 : 커넥션
            
- 03. 데이터를 송수신 한다
        
    1. 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다.
        
        1. `write` 호출 → 송신 데이터를 프로토콜 스택에 전달
        2. 송신용 버퍼 메모리 영역 저장
        3. 데이터 크기 애플리케이션 사정에 따라 결정 - 프로토콜 스택 제어 불가
        
        (그림 2-5)
        
        - MTU, Taximum Transmission Unit : 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이, 이더넷에서는 보통 1,500 바이트
        - MSS, Maximum Segment Size : 헤더를 제외한 것이 하나의 패킷으로 운반 할 수 있는 데이터의 최대 길이
            - TCP/IP 헤더 길이 보통 40바이트, 암호화 등 프로토콜 옵션 추가시 헤더는 더 길어짐
    2. 데이터가 클 때는 분할하여 보낸다
        
        - 송신 버퍼에 들어 있는 데이터를 맨 앞부터 차례대로 MSS 크기에 맞게 분할, 각 조각을 패킥에 넣어 송신 (그림 2-6)
    3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다.
        
        - 조각이 통신 개시부터 따져서 몇 번째 바이트에 해당하는지를 세어둠.
        - 시퀀스 번호 : 데이터의 조각을 송신할 때 세어둔 값을 TCP헤더에 기록
        - 누락이 없는 것을 확인하면 수신측은 그 이전에 수신한 데이터와 합쳐서 데이터를 몇 번째 바이트까지 수신한 것인지 계산 → TCP 헤더의 ACK 번호에 기록하여 송신측에 전달 (수신 확인 응답)
        - SYN에 1을 설정할 때 시퀀스 번호에도 값을 설정하게 되어 있어 시퀀스 번호의 값이 초기값
        - 데이터 흐름이 양방향인 경우 대응해서 좌우로 역전시킨 것을 덧붙이는 형태
        
        (그림 2-9)
        
        - 최초의 초기값 통지가 도중에서 없어질 수 있으므로 이것이 서버에 도착한 것을 알리기 위해 ACK 번호를 반송
            
        - TCP는 이 방법으로 상대가 데이터를 받은 것을 확인하는데, 확인 할 때까지 송신한 패킷을 송신용 버퍼 메모리 영역에 보관
            
        - ACK 번호가 상대로부터 돌아오지 않으면 패킷을 다시 보냄
            
            → 구조가 강력, 다른 곳에서 오류를 회복 조치할 필요 없음
            
        - TCP가 아무리 다시 보내도 데이터가 도착하지 않는 경우
            
            → 한 없이 다시 보내면 곤란하므로 TCP는 몇번 다시 보낸 후 회복의 전망이 없는 것으로 보고 데이터 송신 동작을 강제로 종료하고 애플리케이션에 오류 통지
            
        
        > 시퀀스 번호와 ACK 번호로 패킷이 수신측에 도착한 것을 확인
        
    4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다.
        
        - 타임아웃 값
        - 구체적으로는 데이터 송신 동작을 실행하고 있을 때 항상 ACK 번호가 돌아오는 시간을 계측해 둠
    5. 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다.
        
        - 윈도우 제어는 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법
        - 수신측의 능력을 초과하여 패킷을 보내는 사태가 일어날 수도 있음 → (그림 2-10)
        - 윈도우 제어 방식의 개념 : 먼저 수신측에서 송신윽에 수신 가능한 데이터 양을 통지하고, 수신측은 이 양을 초과하지 않도록 송신 동작을 실행
        - (그림 2-11) 수신 처리 끝나고 수신 버퍼에 빈 부분이 생기면 그 분량만큼 수신할 수 있는 데이터 양을 늘리므로 TCP 헤더의 윈도우 필드에서 이것을 송신측에 알림
        - 윈도우 사이즈 : 수신 가능한 데이터 양의 최대값
    6. ACK 번호와 윈도우를 합승한다.
        
        - 윈도우 통지의 타이밍 : 윈도우 통지가 필요한 것은 수신측이 수신 버퍼에서 데이터를 추출하여 애플리케이션에 건네 주었을때, 데이터를 건네주고 수신 버퍼의 빈 영역이 늘어 났을때
            
        - 매번 ㅁ차 번호 통지와 윈도우 통지의 패킷이 하나씩 따로따로 송신측에 보내지면 패킷이 많아져 효율성 저하.
            
            → ACK 번호의 손신을 대조할 때 윈도우 통지가 일어나면 ACK 번호와 윈도우를 한 개의 패킷에 합승시켜서 통지해서 패킷의 수를 줄일 수 있음
            
    7. HTTP 응답 메시지를 수신한다
        
        응답 메시지가 돌아올 때까지 다소 시간이 걸리므로 수신 버퍼에 데이터가 들어가지 않음.
        
        프로토콜 스택은 의뢰 받은 작업
        
        - 수신 버퍼에서 수신 데이터를 추출해서 애플리케이션에 건네주는 작업을 잠시 보류
        - 서버에서 응답 메시지의 패킷이 도착했을 때 그것을 수신해서 애플리케이션에 건내주는 작업 재개
- 04. 서버에서 연결을 끊어 소켓을 말소한다
        
    1. 데이터 보내기를 완료 했을 때 연결을 끊는다
        
        웹의 동작은 서버가 응답을 반송하면 끝나도록 규칙으로 정해져 있으므로 서버에서 보낸 데이터를 전부 수신 완료하면 클라이언트도 종료
        
    2. 소캣을 말소한다
        
        서버와의 대화가 끝나면 소캣을 사용 할 수 없지만 바로 말소하지 않고 잠시 기다린 후 말소한다.
        
        소켓을 말소하면 거기에 기록되어 있던 제어 정보가 없어지므로 소켓에 할 당되어 있던 포트번호 알 수 업음.
        
    3. 데이터 송수신 동작을 정리한다
        
        (그림 2-13)
        
- 05. IP와 이더넷의 패킷 송수신 동작
        
    1. 패킷의 기본
        
        송신처와 수신처의 기기를 묶어서 `엔드노드`
        
        (그림 2-16) MAC 헤더 라우터가 패킷을 중계할 때 바꾸어 쓰고, 수신처는 그 다음 라우터가 됨
        
    2. 패킷 송수신 동작의 개요
        
        프로토콜 스택의 IP 담당 부분의 패킷 송신 동작
        
        IP 헤더 : IP 프로토콜에 규정된 규칙에 따라 IP 주소로 표시된 목적지까지 패킷을 전달할때 사용하는 제어 정보 기록
        
        MAC 헤더 : 이더넷 등의 LAN을 사용해서 자가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어 정보 기록
        
        > IP 담당 부분 두개의 헤더 덧붙임 MAC 헤더 : 이더넷 용 헤더, MAC 주소 IP 헤더 : IP 용 헤더, IP 주소
        
        IP가 패킷을 송수신하는 동작은 제어 패킷이든지, 데이터의 패킷이든지 패킷의 역할에 상관없이 모두 같음
        
    3. 수신처 IP 주소를 기록한 IP 헤더를 만든다
        
        - 수신처 IP 주소 : 패킷을 어디로 전달해야하는지, 가장중요
        - 송신처 IP 주소
        
        > IP헤더의 수신처 IP 주소에는 통신 상대의 주소를 설정. 송신처 IP 주소는 송신처가 되는 LAM 어댑터를 판단하여 주소를 설정
        
        경로표
        
        넷마스크 : IP 주소의 네트워크 번호와 호스트 번호의 경계를 결정하는 값
        
        맨 위 행 : 목적지와 넷마스크가 0.0.0.0으로 등록 - 기본 게이트웨이
        
        프로토콜 번호라는 필드에도 값을 설정
        
    4. 이더넷용 MAC 헤더를 만든다.
        
        > IP 담당 부분은 IP 헤더를 붙였으면 그 앞에 MAC 헤더를 붙임. MAC 헤더는 이더넷에서 사용하는 헤더로서 수신처나 송신처의 MAC 주소등이 기록
        
        - 3개 이더 타입(EtherType) : 사용하는 프로토콜 종류
        - 송신처 MAC 주소
        - 수신처 MAC 주소
        
        > IP 담당 부분은 경로표의 Gateway 항목의 값에서 패킷을 거네줄 상대를 판단
        
    5. ARP로 수신처 라우터의 MAC 주소를 조사한다
        
        - ARP Address Resolution Protocol : MAC 주소를 조사할 때는 ARP 사용
            - 조사한 결과는 ARP 캐시라는 메모리 영역에 보존해서 다시 이용
            - ARP 캐시에 저장된 값은 시간이 되면 삭제 (OS 정책 따름)
    6. 이더넷의 기본
        
        - 이더넷 : 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술
        - (그림 2-22)
            - Transceiver (트랜시버) : 네트워크 전체에 신호가 흐르고 수신처 해당 기기는 패킷 수신, 나머지는 패킷 폐기
            - 트렁크 케이블 → 리피터 허브 / 트랜시버 케이블 → 트위스트 페어 케이블 : 신호가 전원에게 전달
            - 스위칭 허브 : 수신처 MAC 주소로 나타내는 원하는 기기가 존재하는 부분에만 신호가 흐르고, 다른 곳에는 신호가 흐르지 않음
    7. IP 패킷을 전기나 빛의 신호로 변환하여 송신한다
        
        - LAN 어댑터 : 디지털 데이터를 전기나 빛의 신호로 변환 해서 네트워크의 케이블에 송출
        
        > LAN 어댑터의 ROM에는 전세계에서 중복되지 않도록 일원화 되어 관리되는 MAC 주소가 제조할 때 기록됨 LAN 어댑터에 기록된 MAC 주소는 LAN 드라이버가 MAC 회로에 설정
        
    8. 패킷에 3개의 제어용 데이터를 추가한다
        
        (그림 2-24) MAC 회로는 먼저 송신 패킷을 버퍼 메모리에서 추출하고 맨 앞에는 `프리앰블`과 `스타트 프레임 딜리미터`라는 두개의 데이터를, 맨 끝에는 `프레임 체크 시퀀스` (FCS)라는 오류 검출용 데이터를 부가
        
        클록 : 비트 구분을 나타내는 신호 보내는 방법
        
    9. 허브를 향해 패킷을 송신한다
        
        > LAN 어댑터의 MAC 회로가 공통 형식의 신호를 만들고 PHY(MAU) 회로가 케이블에 송출하는 형식으로 변환해서 케이블에 송신
        
    10. 돌아온 패킷을 받는다
        
    11. 서버의 응답 패킷을 IP에서 TCP로 넘긴다
        
- 06. UDP 프로토콜을 이용한 송수신 동작
    1. 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적이다.
	    데이터를 전부 보낸 후에 수신측에서 수신 확인 응답을 받는 방법
	    전부 다시 보내는 방법을 선택하면 패킷이 한 개만 없어졌어도 전체를 다시 보내므로 비효율적
	    수신확인 응답 패킷도 필요 없음
    2. 제어용 짧은 데이터
	    UDP에는 TCP와 같은 수신 확인이나 윈도우가 없어서 데이터 송수신 전에 제어 정보를 주고 받을 필요가 없고 접속이나 연결 끊기 단계가 없음
    3. 음성 및 동영상 데이터
	    음성이나 영상의 데이터를 보낼때 UDP 사용
	    재생 타이밍이 맞지 않으면 중간에 끊긴 음이나 영상을 원래대로 되돌릴 수 없기 때문에 데이터가 도착해도 쓸모 없음