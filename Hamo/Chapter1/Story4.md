# Story4. 프로토콜 스택에 메시지 송신을 의뢰한다.

IP 주소를 조사했으면 액세스 대상 서버에 메시지를 송신하도록 OS 내부에 있는 `프로토콜 스택`에 의뢰한다.

이 동작은 모든 네트워크 어플리케이션에 해당된다.

## 데이터 송, 수신 동작

- 양쪽에 파이프가 연결된 느낌이다.
    - 데이터를 파이프에 쏟아 부으면 반대쪽으로 도착해서 추출하는 느낌
    - 양방향으로 데이터를 보낼 수 있다.
- 송, 수신 이전에 파이프를 연결하는 동작도 필요하다!!
- 파이프 양끝에 있는 데이터의 출입구를 소켓이라고 부른다.
    - 먼저 소켓을 만들고 연결한다.
    - 서버 먼저 만들고 클라이언트가 연결하기를 기다린다.
- 데이터를 전부 보내고 나면 파이프가 분리된다.
    - 파이프 분리는 어느 쪽에서 먼저하든 상관없다.
    - 분리가 끝나면 소켓을 말소해서 통신 동작이 종료된다.

### 요약

1. 소켓을 만든다. (소켓 작성 단계)
2. 서버측의 소켓에 파이프를 연결한다. (접속 단계)
3. 데이터를 송, 수신한다. (송, 수신 단계)
4. 파이프를 분리하고 소켓을 말소한다. (연결 끊기 단계)

→ 이 단계에 따라서 Socket 라이프러리 안의 프로그램 부품을 호출하여 송, 수신 동작을 수행한다.

위에 있는 모든 동작은 프로토콜 스택에서 수행하고 여기서 말하는건 전부 의뢰 과정이다.

## 의뢰 단계

- socket이라는 부품을 호출해서 클라이언트의 소켓을 만든다.
    - 소켓이 생기면 디스크립터가 돌아오는데 이것은 소켓을 식별하기 위해 사용한다.
        - 송, 수신이 여러번 진행되는 경우에 필요함
- connect라는 부품을 호출해서 만든 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰한다.
    - 디스크립터, 서버의 IP 주소, 포트 번호를 지정한다
    - IP 주소는 네트워크에 존재하는 각 컴퓨터를 식별하기 위해 가지는 값이다.
        - IP 주소는 기기에 장착된 각각의 네트워크용 하드웨어에 할당된다.
        - IP 주소로 지정할 수 있는 것은 네트워크의 어느 컴퓨터 까지이다.
    - IP 주소만으로 소켓을 지정할 수는 없기 때문에 사용되는게 포트 번호이다.
    - 디스크립터 → 나의 소켓을 식별, 포트번호 → 상대측의 소켓을 식별
    - 클라이언트의 소켓번호는 소켓을 만들 때 프로토콜 스택이 적당한 값을 골라서 할당한다. 그리고 이 값을 프로토콜 스택이 접속 동작을 실행할 때 서버에 통지한다.
- write라는 부품을 호출해서 소켓에 데이터를 쏟아붓도록 의뢰한다.
    - write를 호출할 때 디스크립터와 송센 데이터를 지정해준다.
    - 그리고 프로토콜 스택이 송신한다.
    - 서버가 이걸 받아서 내용을 조사한 다음에 응답
- read라는 프로그램 부품을 통해 메시지 수신 동작을 의뢰한다.
    - 응답 메시지를 저장하기 위한 메모리 영역을 지정한다. → 수신 버퍼
    - 응답 메시지가 돌아오면 read가 받아서 수신 버퍼에 저장한다.
- close 부품을 호출하여 연결 끊기 단계에 들어가도록 의뢰한다.
    - 소켓 사이를 연결한 파이프와 소켓이 말소된다.
    - HTTP 프로토콜 기준으로 응답 메시지의 송신이 완료되면 서버 측에서 close를 호출해서 연결을 끊는다.
    - 클라이언트가 이걸 받아서 연결 끊기 단계로 들어간다.
    - read로 의뢰한 동작이 완료되면 연결이 끊겼다는 사실을 브라우저에 통지한다.
    - 브라우저도 close를 호출해서 연결 끊기 단계를 의뢰한다.
    - HTTP는 1개의 데이터를 읽을 때 마다 위 과정을 전부 수행한다.
    - 복수의 데이터를 읽을 때 비효율 적이다.
        - 연결을 안 끊고 게속 리퀘스트와 응답을 주고 받는 방법이 마련되어있다. (HTTP 1.1에서도 사용 가능)
