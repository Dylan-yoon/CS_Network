# Story3. 데이터를 송,수신한다.

- 엔드노드 == 엔드포인트?

connect에서 어플리케이션에 제어가 되돌아오면 송, 수신 동작에 들어간다.

이 동작은 어플리케이션이 write를 호출하여 송신 데이터를 프로토콜 스택에 건네주는 곳부터 시작된다.

## 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다.

- 프로토콜 스택은 데이터의 내용이 무엇인지 모른다.
- 바로 송신하는게 아니라 일단 버퍼 메모리 영역에 저장한다.
    - 이유는 데이터를 한방에 전달하는 경우도 있지만 조금씩 전달하는 경우도 있기 때문이다.
    - 조금씩 주는데 계속 보내면 효율이 안좋다.
    - 일정량 모아서 보내는데 얼마나 모을지는 다 다르기 때문에 MTU, 타이밍에 따라서 판단된다.
- 첫 번째 판단 방법: MTU라는 매개변수를 바탕으로 한 패킷에 저장할 수 있는 데이터의 크기를 판단한다.
    - MTU → 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이
    - MTU는 앞에 헤더를 포함하는데 이걸 제외한 길이를 MSS라고 한다.
- 두 번째 판단 방법: 끝까지 모으려고하면 송신 동작이 지연되니까 적당한 곳에서 실행해버린다.
    - 프로토콜 스택은 내부에 있는 타이머로 일정 시간 이상 경과하면 패킷을 송신한다.
- 둘은 상반되는데 전자는 시간이 지연될 가능성이 있고 후자는 효율이 떨어진다.
    - 규정은 없고 알아서 잘 조절해야 한다. (OS에 따라 다름)
- 어플리케이션측에서 송신 타이밍을 제어할 수도 있다.
    - 의뢰할 때 바로 보내라는 옵션을 지정할 수도 있다.

## 데이터가 클 때는 분할하여 보낸다.

- 긴 데이터를 보낼 경우(MSS의 길이를 초과하는 경우)에는 데이터를 맨 앞부터 차례로 MSS의 크기에 맞게 쪼개서 조각들을 한 개씩 패킷에 넣어서 송신한다.

## ACK 번호를 사용하여 패킷이 도착했는지 확인한다.

- TCP에는 송신한 패킷이 상대에게 올바르게 도착했는지 확인하고, 도착하지 않았으면 다시 송신하는 기능이 있으므로 패킷을 송신한 후에는 확인 동작으로 넘어간다.
- TCP 담당부분은 데이터를 쪼갤 때 조각이 제일 앞부터 몇 번째 바이트 까지인지 세어두고 이를 TCP 헤더에 기록한다.
    - 시퀀스 번호라는 항목에 기록한다.
- 데이터의 크기는 헤더에 기록하지 않고 송신측에서 계산한다.
    - 패킷 전체에서 헤더 빼면 크기가 나온다.
- 위 정보로 수신측에서 패킷이 누락되었는지 확인할 수 있다.
    - 1460까지 받고 1461이 오면 누락이 없다는 것을 뜻한다.
- 누락이 없는 것을 확인하면 데이터를 몇 번째 바이트까지 수신한 것인지 계산해서 TCP 헤더의 ACK 번호에 기록해서 송신측에 돌려준다. → 수신 확인 응답
- 시퀀스 번호는 난수로 시작한다.
    - 악의적인 공격을 피하기 위해서이다.
    - 난수로 정하면 상대가 모르기 땨문에 접속 동작에서 SYN을 1로 만들어서 송신측에 보낼 때 통지한다.
- 서버측에서 클라이언트측으로 데이터가 흐르는 경우도 있는데 이때는 서버측에서 시퀀스 번호를 산출해서 클라이언트에 통지한다.
    - 초기 시퀀스 번호를 클라이언트가 서버에 주면 잘 도착한 것을 알리기 위해 ACK 번호랑 서버측 초기 시퀀스 번호를 보내고 클라이언트가 잘 받으면 ACK 번호 다시 보내준다.
    - 위 과정이 끝나면 데이터 송, 수신 동작에 들어간다.
    - 시퀀스 번호 + 데이터를 서로 서로 주고받고 잘 받으면 서로 서로 ACK 번호를 돌려준다.
    - ACK 번호가 안오면 TCP는 패킷을 다시 보낸다. (이걸 확인할 때까지 버퍼 메모리에 패킷을 남겨둠)
- 이 구조는 완벽하기 때문에 다른 곳에서 오류를 회복 조치할 필요가 없다.
    - 오류를 검출하면 버리기만 한다.
- 아무리 다시 보내도 도착하지 않는 경우에 TCP는 몇번 보내보다가 데이터 송신 동작을 강제 종료하고 어플리케이션에 오류를 통지한다.

## 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다.

- ACK 번호가 돌아오는 시간을 예측해서 어느 정도 길게 설정해야 한다.
    - ACK 번호가 돌아오기 전에 다시 보내야 하는 사태가 생길 수 있기 때문이다.
- 너무 긴 것도 안좋기 때문에 적당한 시간을 설정해야 한다.
- TCP는 대기 사간을 동적으로 변경하는 방법을 취하고 있다.
    - ACK 돌아오는 시간을 기준으로 대기 시간을 판단한다.
    - 데이터 송신 동작을 실행하고 있을 때 항상 시간을 계측해두고 돌아오는 시간이 지연된다면 대기 시간도 늘려버린다. 반대로 바로 돌아오면 줄여버린다.

## 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다.

- ACK 번호가 돌아올 때까지 아무것도 안하면 낭비이다.
- 윈도우 제어라는 방식에 따라서 송신과 ACK 번호 통지의 동작을 실행한다.
- 윈도우 제어는 ACK 번호를 기다리지 않고 차례대로 연속에서 복수의 패킷을 보내는 방법이다.
- 문제는 수신측의 능력을 초과할 수 있다.
    - 수신측은 수신 버퍼에 데이터를 임시 보관하고 수신 처리를 진행하기 때문에 받아서 메모리 버퍼에 보관할 텐데 너무 빠르게 줘버리니까 메모리 용량을 초과할 수도 있다.
    - 해결 방법은 송신측에 수신 가능한 데이터 양을 통지하는 것이다. → 윈도우 제어 방식의 개념
- 수신 처리가 끝나고 수신 버퍼에 빈 부분이 생기면 수신할 수 있는 공간이 생기는데 TCP 헤더의 윈도우 필드에서 이것을 송신측에 알린다.
- 수신 가능한 데이터 양의 최대값을 윈도우 사이즈라고 부른다.

## ACK 번호와 윈도우를 합승한다.

송, 수신 동작의 효율성을 높이기 위해서는 ACK 번호와 윈도우를 통지하는 타이밍을 고려해야 한다.

- 윈도우 통지를 계속 할 필요가 없다.
    - 윈도우의 값은 송신측에서 데이터를 보낼 때 감산해서 계산할 수 있기 때문에
    - 빈 공간이 났을 때만 송신측에 알려주면 된다.
- 효율적인 방법
    - 기다렸다가 한번에 보낸다.
    - ACK 번호 통지가 여러번 일어나면 끝 번호만 보낸다.
    - 윈도우 통지도 똑같다.

## HTTP 응답 메시지를 수신한다.

- 어플리케이션은 리퀘스트 메시지 송신을 의뢰하고, 이것이 끝나면 응답 메시지를 받기 위해 read 프로그램을 호출한다.
- 프로토콜 스택이 응답 메시지가 돌아오면 수신 버퍼에서 데이터를 추출해서 어플리케이션에 전달한다.
    - 수신한 데이터 조각과 TCP 헤더의 내용을 조사해서 데이터가 누락됐는지 확인하고 문제가 없으면 ACK 번호를 반송한다.
    - 버퍼에 잠깐 보관했다가 조각을 연결해서 데이터를 복원한 후 어플리케이션에 전달한다.
    - 어플리케이션에 데이터를 건네주고 타이밍을 가늠해서 윈도우를 송신측에 통지한다.
    - 거꾸로
