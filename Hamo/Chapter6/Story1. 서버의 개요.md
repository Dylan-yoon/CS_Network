# Story1. 서버의 개요
## 클라이언트와 서버의 차이점

- 하드웨어나 OS 부분은 클라이언트와 다른 것도 있다.
- 네트워크에 관한 부분 LAN 어댑터, 프로토콜 스택, Socket 라이브러리 등의 기능은 클라이언트와 다르지 않다.
- 가지고 있는 기능은 같아도 사용하는 방법까지 같은 것은 아니다.
    - 서버는 클라이언트의 접속 동작을 기다리기 떄문에 Socket 라이브러리의 사용법이 조금 다르다.
- 서버는 동시에 다수의 클라이언트 PC와 대화한다.

## 서버 어플리케이션의 구조

- 클라이언트가 접속할 때마다 새로 서버 프로그램을 작동하여 서버 어플리케이션이 클라이언트와 1대1로 대화하는 방법을 선택하는 것이 일반적이다.
    - 하나의 프로그램으로 여러 클라이언트를 처리하는 것은 어렵기 때문이다.
- 구체적으로는 다음과 같이 서버 프로그램을 만든다.
    - 서버 프로그램을 접속을 기다리는 부분과 클라이언트와 대화하는 부분 둘로 나누어 만든다.
    - 클라이언트와 대화 하는 부분은 새 클라이언트가 접속할 떄마다 잇달아 기동되므로 클라이언트와 1대1로 대응한다.

## 서버측의 소켓과 포트 번호

- 데이터를 송, 수신하는 동작의 관점에서 보면 클라이언트와 서버라는 상태로 역할을 고정시키는 것은 좋은 방법이 아니다.
    - 다양한 형태로 데이터를 송, 수신하는 구조를 지원하려면 클라이언트와 서버라는 식으로 역할을 결정하지 말고 좌우 대칭으로 어디에서나 자유롭게 데이터를 송신할 수 있도록 해두는 방법이 좋다.
- 접속 동작은 좌우 대칭으로 만들 수 없다.
    - 한쪽은 기다리고 한쪽은 연결해야 한다.
- 서버쪽은 아래와 같은 순서로 송수신 동작을 수행한다.
    - 소켓을 만든다.
    - 소켓을 접속 대기 상태로 만든다.
    - 접속을 접수한다.
    - 데이터를 송, 수신한다.
    - 파이프를 분리하고 소켓을 말소한다.
- bind(소켓 번호를 기록) → listen(소켓에 접속하기를 기다림) → accept(접속을 접수, 패킷의 도착을 기다리는 상태) → 클라이언트와 대화하는 부분을 기동한다.
- 소켓을 식별하기 위해 디스크립터를 사용하는 이유
    - 접속 대기의 소켓에는 클라이언트측의 IP 주소와 포트 번호가 기록되어 있지 않기 때문
    - 디스크립터라는 한 개의 정보로 식별하는 쪽이 간단하기 때문
