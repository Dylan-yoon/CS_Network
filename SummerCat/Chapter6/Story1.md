패킷이 웹 서버에 도착한 이후부터의 과정

# 서버의 개요
## 클라이언트와 서버의 차이점
클라이언트측 애플리케이션과는 Socket 라이브러리의 사용법(프로그램 부품)이 다르다.

서버측 애플리케이션은 동시에 다수의 클라이언트 PC와 대화한다.

## 서버 애플리케이션의 구조
서버는 동시의 복수의 클라이언트와 통신 동작을 실행
  - 하나의 프로그램으로 여러 클라이언트를 상대하기는 어렵기 때문에, 클라이언트가 접속할 때마다 새로 서버 프로그램을 작동하여 1:1로 대화
  - 서버 프로그램은 두 부분으로 나누어져 있다.
    - 서버 프로그램 접속을 기다리는 부분
      - 서버 프로그램을 작동해서 설정 파일 읽기 등의 초기화 동작을 마쳤을 때 이 부분을 실행
      - 소켓을 작성하고 소켓을 클라이언트에서의 접속 동작을 기다리는 상태로 만든 후 휴식 상태가 됨
      - 클라이언트가 접속했을 때 다시 작동하여 접속을 기다림
      - 클라이언트와 대화하는 부분을 작동시켜 접속이 끝난 소켓을 건네준다.
    - 클라이언트와 대화하는 부분
      - 접속이 끝난 소켓을 사용하여 클라이언트와 대화
      - 클라이언트와 1:1로 대응
      - 서버 OS의 멀티태스크/멀티스레드 기능을 활용함

## 서버측의 소켓과 포트 번호
접속 동작에서 접속을 기다리는 쪽이 서버, 접속하는 쪽이 클라이언트

### 서버의 데이터 송수신 동작
1. **소켓 작성 단계**
    - `socket`을 호출하여 소켓을 만든다.
2. 접속 대기 상태: 소켓을 접속 대기 상태로 만듦
    - `bind`를 호출하여 소켓에 포트 번호를 기록
      - 클라이언트 측에서 접속 동작을 실행할 때 서버 측의 소켓에 할당한 포트 번호
    - `listen`을 호출하여 소켓에 접속하기를 기다리는 상태라는 제어 정보를 기록
3. **접속 접수 단계**: 접속을 접수
    - `accept`를 호출하여 접속을 접수
    - 서버 애플리케이션을 기동한 후 즉시 실행되므로 이 시점에서는 아직 클라이언트의 접속 패킷이 도착하지 않음
    - 서버측은 패킷의 도착을 기다리는 상태가 되고, 애플리케이션은 쉬는 상태가 된다.
    - 애플리케이션에서 접속 패킷이 도착하면 응답 패킷을 반송하여 접속 접수 동작을 실행
    - 접속 대기의 소켓을 복사하여 새로운 소켓을 만들고, 접속 상대의 정보를 비롯한 제어 정보를 새 소켓에 기록
      - 클라이언트 측 IP주소, 포트 번호, 서버 측 IP주소, 포트 번호를 기록
      - 애플리케이션과 프로토콜 스택 사이에 소켓을 식별할 때에는 디스크립터를 사용한다.
        - 접속 대기 상태일 때에는 위의 정보가 아직 준비되지 않았기 때문
    - 새 소켓이 클라이언트 측의 소켓과 연결 완료
    - 접속 대기 상태의 소켓은 그대로 존재 (이 소켓을 추가 접속 요청이 있을 때 복사)
4. **송수신 단계**: 데이터 송수신
    - 패킷이 도착했
6. **연결 끊기 단계**: 파이프를 분리하고 소켓을 말소
